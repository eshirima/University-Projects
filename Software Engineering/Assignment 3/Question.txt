After completing your designs, you begin implementing the project in C++ from your designs (for specifics see below).

You are to take your class diagrams and sequence diagrams and create classes with the fields and methods and calling behaviour that reflect what you modeled. For instance, in the class example we had a class source_code_collector_controller. The source-code for this class should have two fields collector of type source_code_collector and output of type count_output and all the operations as laid out in the class (process_input(), parse_input(), count_entities(), and output_counts()). 

The rudimentary behavior of the methods also needs to be placed in source-code. That is, object creation and method calls need to placed within methods, however, the project does not actually need to input/generate/output charts (similar to what is shown in the sequence diagrams). For example, the method parse_input should create a cpp_parser, call parse, delete the parser, and return an ast, but it does not need to parse a file or generate a full ast, just an empty ast object. If there is iteration through something, show it with a loop and what methods it will call in that loop. In essence, you need the bare bones classes and methods and how they call and interact for the project such that a person would only need to fully implement the methods (such as the parsing of a file, or how a chart is generated) to fully solve the problem. Too show what your program is doing, each function MUST print out what class it belongs to and what method was called (i.e., trace statements).

You MUST have a file main.cpp which contains the main function and creates your controller class(es) and calls the methods to show how it would actually work. For instance, for the class example, main.cpp will create a source_code_collector_controller and call process_input() and output_counts().

The project MUST be able to compile and run (without failing) on wasp or hornet. You MUST also provide either one of the following a Makefile that builds and runs your project or support building with CMake. For a Makefile, typing make will build the project and typing make run will run the project. Ideally, typing make run should also build it if not already built. For CMake, it must build the project and you MUST support in-source and out-of-source builds, and support running with CTest or a custom target run.

During the coding, you will likely find that your design is unworkable or something is missing. As you work, correct your design artifacts (in the design directory) and indicate what was wrong and how you fixed it in a file CHANGES in the src directory. Even if your design was perfect you must have a file CHANGES.
